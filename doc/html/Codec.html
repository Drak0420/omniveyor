<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Omniveyor: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Omniveyor
   </div>
   <div id="projectbrief">Root Repository for the OmniVeyor Robots</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<p> Matrix Structure:</p>
<p>S = Size of original data in bytes. N = ceil(S / M) = Count of blocks in the original data.</p>
<p>(1) Matrix Construction </p><pre class="fragment">A = Original data blocks, N blocks long.
D = Count of dense/heavy matrix rows (see below), chosen based on N.
E = N + D blocks = Count of recovery set blocks.
R = Recovery blocks, E blocks long.
C = Matrix, with E rows and E columns.
0 = Dense/heavy rows sum to zero.

+---------+-------+   +---+   +---+
|         |       |   |   |   |   |
|    P    |   M   |   |   |   | A |
|         |       |   |   |   |   |
+---------+-----+-+ x | R | = +---+
|    D    |  J  |0|   |   |   | 0 |
+---------+-+---+-+   |   |   +---+
|    0      |  H  |   |   |   | 0 |
+-----------+-----+   +---+   +---+

A and B are Ex1 vectors of blocks.
    A has N rows of the original data padded by H zeros.
    R has E rows of encoded blocks.

C is the ExE hybrid matrix above:
    P is the NxN peeling binary submatrix.
        - Optimized for success of the peeling solver.
    M is the NxD mixing binary submatrix.
        - Used to mix the D dense/heavy rows into the peeling rows.
    D is the DxN dense binary submatrix.
        - Used to improve on recovery properties of peeling code.
    J is a DxD random-looking invertible submatrix.
    H is the 6x18 heavy GF(256) submatrix.
        - Used to improve on recovery properties of dense code.
    0 is a Dx6 zero submatrix.

C matrices for each value of N are precomputed offline and used
based on the length of the input data, which guarantees that C
is invertible.
</pre><p>(2) Generating Matrix P </p><pre class="fragment">The Hamming weight of each row of P is a random variable with a
distribution chosen to optimize the operation of the peeling
solver (see below).
For each row of the matrix, this weight is determined and 1 bits
are then uniformly distributed over the N columns.
The GeneratePeelRowWeight() function determines row weights.
</pre><p>(3) Generating Matrix M </p><pre class="fragment">Rows of M are generated with a constant weight of 3 and 1 bits are
uniformly distributed over the H columns.
</pre><p>(4) Generating Matrix D </p><pre class="fragment">Matrix D is generated with a Shuffle-2 Code, a novel invention.
Shuffle-2 codes produce random matrices that offer possibly the
fastest matrix-matrix multiplication algorithm for this purpose.
Each bit has a 50% chance of being set.
</pre><p>(5) Generating Matrix H </p><pre class="fragment">The heavy matrix H is also a novel invention in this context.
Adding these rows greatly improves invertibility of C while providing
a constant-time algorithm to solve them.
H is a 6x18 random byte matrix.
Each element of H is a byte instead of a bit, representing a number
in GF(256).
</pre><p>(6) Matrix Solver </p><pre class="fragment">An optimized sparse technique is used to solve the recovery blocks.
</pre><hr  />
<p> Sparse Matrix Solver:</p>
<p>There are 4 stages to this sparse solver:</p>
<p>(1) Peeling</p><ul>
<li>Opportunistic fast solution for first N rows. (2) Compression</li>
<li>Setup for Gaussian elimination (3) Gaussian Elimination</li>
<li>Gaussian elimination on a small square matrix (4) Substitution</li>
<li>Solves for remaining rows from initial peeling</li>
</ul>
<p>See the code comments in Wirehair.cpp for documentation of each step.</p>
<p>After all of these steps, the row values have been determined and the matrix solver is complete. Let's analyze the complexity of each step:</p>
<p>(1) Peeling</p><ul>
<li>Opportunistic fast solution for first N rows.</li>
</ul>
<p>Weight determination : O(k) average Column reference update : Amortized O(1) for each column</p>
<p>If peeling activates, Marking as peeled : O(1)</p>
<p>Reducing weight of rows referencing this column : O(k) If other row weight is reduced to 2, Regenerate columns and mark potential Deferred : O(k) End End</p>
<p>So peeling is O(1) for each row, and O(N) overall.</p>
<p>(2) Compression</p><ul>
<li>Setup for Gaussian elimination on a wide rectangular matrix</li>
</ul>
<p>The dense row multiplication takes O(N / 2 + ceil(N / D) * 2 * (D - 1)) where D is approximately SQRT(N), so dense row multiplication takes: O(N / 2 + ceil(SQRT(N)) * SQRT(N)) = O(1.5*N).</p>
<p>(3) Gaussian Elimination</p><ul>
<li>Gaussian elimination on a (hopefully) small square matrix</li>
</ul>
<p>Assume the GE square matrix is SxS, and S = sqrt(N) on average thanks to the peeling solver above.</p>
<p>Gaussian elimination : O(S^3) = O(N^1.5) bit operations</p>
<p>This algorithm is not bad because the matrix is small and it really doesn't contribute much to the run time.</p>
<ul>
<li>Solves for rows of small square matrix</li>
</ul>
<p>Assume the GE square matrix is SxS, and S = sqrt(N) on average thanks to the peeling solver above.</p>
<p>Solving inside the GE matrix : O(S^2) = O(N) row ops</p>
<p>(4) Substitution</p><ul>
<li>Solves for remaining rows from initial peeling</li>
</ul>
<p>Regenerate peeled matrix rows and substitute : O(N*k) row ops</p>
<p>So overall, the codec scales roughly linearly in row operations, meaning that the throughput is somewhat stable over a wide number of N.</p>
<hr  />
<p> Encoding:</p>
<p>The first N output blocks of the encoder are the same as the original data. After that the encoder will start producing random- looking M-byte blocks by generating new rows for P and M and multiplying them by B.</p>
<hr  />
<p> Decoding:</p>
<p>Decoding begins by collecting N blocks from the transmitter. Once N blocks are received, the matrix C' (differing in the first N rows from the above matrix C) is generated with the rows of P|M that were received. Matrix solving is attempted, failing at the Gaussian elimination step if a pivot cannot be found for one of the GE matrix columns (see above).</p>
<p>New rows are received and submitted directly to the GE solver, hopefully providing the missing pivot. Once enough rows have been received, back-substitution reconstructs matrix B.</p>
<p>The first N rows of the original matrix G are then used to fill in any blocks that were not received from the original N blocks, and the original data is recovered. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
