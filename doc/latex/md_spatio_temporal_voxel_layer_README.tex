This is a drop in replacement for the voxel\+\_\+grid voxel representation of the environment. This package does a number of things to improve on the voxel grid package and extend the capabilities offered to the users, under a L\+G\+PL v2.\+1 license. Developed and maintained by \href{https://www.linkedin.com/in/steven-macenski-41a985101/}{\texttt{ Steven Macenski}} at \href{http://www.simberobotics.com/}{\texttt{ Simbe Robotics}}.

This package sits on top of \href{http://www.openvdb.org/}{\texttt{ Open\+V\+DB}}, an open-\/source C++ library built by Dreamworks \char`\"{}comprising a novel hierarchical data structure and a suite of tools for the efficient storage and manipulation of sparse volumetric data discretized on three-\/dimensional grids. It is developed and maintained by Dream\+Works Animation for use in volumetric applications typically encountered in feature film production.\char`\"{}

Leveraging Open\+V\+DB, we have the ability to efficiently maintain a 3 dimensional voxel-\/representative world space. We wrap this with R\+OS tools and interfaces to the \href{http://wiki.ros.org/navigation}{\texttt{ navigation stack}} to allow for use of this layer in standard R\+OS configurations. It is certainly possible to utilize this package without R\+O\+S/\+Navigation and I invite other competing methodologies to develop here and create interfaces.

Sample videos are shown below of a robot using {\bfseries{7 depth cameras}} with less than 50\% of a core, and another robot using a {\bfseries{V\+L\+P-\/16}}.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 7 Depth Cameras }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ V\+L\+P-\/16 L\+I\+D\+AR  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ 7 Depth Cameras }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ V\+L\+P-\/16 L\+I\+D\+AR  }\\\cline{1-2}
\endhead
\PBS\centering  &\PBS\centering   \\\cline{1-2}
\end{longtabu}


We found in experimental trials with {\bfseries{6}} 7hz dense stereo R\+G\+BD cameras we ran the major move\+\_\+base process at {\bfseries{20-\/50\%}} nominal from {\bfseries{80-\/110\%}} on a 5th gen i7 C\+PU in the global costmap updating using the existing {\ttfamily voxel\+\_\+layer}.

We\textquotesingle{}ve received feedback from users and have robots operating in the following environments with S\+T\+VL\+:
\begin{DoxyItemize}
\item Retail
\item Warehouses
\item Factories
\item Libraries
\item Hospitals
\item Hospitality
\item Robo\+Cup@\+Home
\item Oil and Gas
\end{DoxyItemize}

Steve spoke at R\+O\+S\+Con 2018 about S\+T\+VL and his presentation is \href{https://vimeo.com/292699571}{\texttt{ linked here}} (or click on image).

\href{https://vimeo.com/292699571}{\texttt{ }}\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md38}{}\doxysubsection{Cite This Work}\label{md_spatio_temporal_voxel_layer_README_autotoc_md38}

\begin{DoxyCode}{0}
\DoxyCodeLine{@article\{doi:10.1177/1729881420910530,}
\DoxyCodeLine{    author = \{Steve Macenski and David Tsai and Max Feinberg\},}
\DoxyCodeLine{    title =\{Spatio-\/temporal voxel layer: A view on robot perception for the dynamic world\},}
\DoxyCodeLine{    journal = \{International Journal of Advanced Robotic Systems\},}
\DoxyCodeLine{    volume = \{17\},}
\DoxyCodeLine{    number = \{2\},}
\DoxyCodeLine{    year = \{2020\},}
\DoxyCodeLine{    doi = \{10.1177/1729881420910530\},}
\DoxyCodeLine{    URL = \{https://doi.org/10.1177/1729881420910530\}}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md39}{}\doxysection{$<$strong$>$\+Spatio$<$/strong$>$-\/}\label{md_spatio_temporal_voxel_layer_README_autotoc_md39}
The Spatio in this package is the representation of the environment in a configurable {\ttfamily voxel\+\_\+size} voxel grid stored and searched by Open\+V\+DB.

In addition, buffered measurement readings have the option to run an approximate voxel grid filter, parameterizable at runtime in the configuration yamls. It is incredibly useful to reduce spikes in {\ttfamily move\+\_\+base} cpu due to dense measurement readings when getting close to objects (i.\+e. more points), but does increase the overhead very slightly (1-\/2\%) for nominal operations. It\textquotesingle{}s a trade off but I recommend using it.

Below is an example a size of map that is {\bfseries{trivial}} for the Spatio-\/\+Temportal Voxel Grid to maintain and render. This accounts for a 60,000 sq.\+ft. retail store with 710,765 voxels at a 0.\+05m resolution, with a size in memory of a mere 6.\+45\+MB. ~\newline


\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md40}{}\doxysection{-\/$\ast$$\ast$\+Temporal$\ast$$\ast$}\label{md_spatio_temporal_voxel_layer_README_autotoc_md40}
The Temporal in this package is the novel concept of {\ttfamily voxel\+\_\+decay} whereas we have configurable functions that expire voxels and their occupation over time. Infrasture was created to store times in each voxel after which the voxel will disappear from the map. This is combined with checking inclusion of voxels in current measurement frustums to accelerate the decay of those voxels that do not have measurements but should if still in the scene and remain marked. This is done rather than simply clearing them naively or via costly raytracing. The time it takes to clear depends on the configured functions and acceleration factors.

Voxel acceleration uses given F\+OV to compute the frustum geometry. Depth cameras (e.\+g. Intel Realsense) are modeled with traditional 6-\/planed cubical frustums. 3D lidars (e.\+g. Velodyne V\+LP 16) are modeled with their hourglass-\/shaped F\+OV. Although many 3D lidars have 360 degree horizontal F\+OV, it is possible to use a narrower angle for the clearing frustum by setting the h\+F\+OV parameter accordingly.

Future extensions will also to query a static map and determine which connected components belong to the map, not in the map, or moving. Each of these three classes of blobs will have configurable models to control the time they persist, and if these things are reported to the user.

Below is an example of instantaneous decay, where readings in frustum are accelerated and decayed at each iteration. The models provided can be tuned to do this, or persist through linear or exponental equations. The second example has the acclerated frustum with tuned decay times and acceleration factors in navigation mode.



\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md41}{}\doxysection{Local Costmap}\label{md_spatio_temporal_voxel_layer_README_autotoc_md41}
This package utilizes all of the information coming in from the robot before the decay time for the local costmap. Rather than having a defined, discrete spatial barrier for the local planner to operate in, it instead relies on the user configuration of the layer to have a short decay time of voxels (1-\/30 seconds) so that you only plan in relavent space. This was a conscious design requirement since frequently the local planner should operate with more information than other times when the speed is greater or slower. This natively implements dynamic costmap scaling for speed.

It is the user\textquotesingle{}s responsibility to chose a decay time that makes sense for your robot\textquotesingle{}s local planner. 5-\/15 seconds I have found to be nominally good for most open-\/sourced local planner plugins. I do not recommend using this for planar lidars, 2D raytracing for professional grade lidars is sufficiently efficient and effective.\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md42}{}\doxysection{Global Costmap}\label{md_spatio_temporal_voxel_layer_README_autotoc_md42}
Similar to the local costmap, the amount of information you want to store due to entropy in your scenes depend on your use-\/case. It is certainly possible to {\bfseries{not}} decay the voxels in the global map at all. However, in practical application, I find a time 15-\/45 seconds to be a good balance due to things moving in the scene (i.\+e. store, warehouse, construction zone, office, etc). Permanent voxels set decay to -\/1. I do not recommend using this for planar lidars, 2D raytracing for professional grade lidars is sufficiently efficient and effective.\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md43}{}\doxysection{Mapping}\label{md_spatio_temporal_voxel_layer_README_autotoc_md43}
As the images above suggest, you can use this to map an environment in 3D in realtime if you choose. If you enable mapping mode, then it will maintain the entire voxel grid and you can save the map using the services provided. At the moment, I support mapping but there is no probabilistic (yet!) marking framework, so what the sensor sees is what the map gets. This is likely to change in the near to middle term future as 3D localization becomes more interesting to the enterprise robotics community.

You can run multiple instances of the layer one to map and other to navigate if you want to navigate while mapping the environment. Mapping will also save incremental maps in the launch directory. Maps may be visualized using {\ttfamily vdb\+\_\+viewer}. The costmap and occupancy point clouds will not generate in this mode from this layer. Utility functions are provided so you don\textquotesingle{}t need to learn anything about vdb files to convert to a pcl pointcloud in {\ttfamily \mbox{\hyperlink{vdb2pc_8hpp_source}{vdb2pc.\+hpp}}}.

If you would like to be involved in this work, I would gladly take contributors and coauthors.\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md44}{}\doxysection{Installation}\label{md_spatio_temporal_voxel_layer_README_autotoc_md44}
As of July 8 it is available via {\ttfamily apt-\/get}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo apt-\/get install ros-\/kinetic-\/spatio-\/temporal-\/voxel-\/layer}
\end{DoxyCode}
\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md45}{}\doxysubsection{Install from source}\label{md_spatio_temporal_voxel_layer_README_autotoc_md45}
Required dependencies R\+OS Kinetic, navigation, Open\+V\+DB, T\+BB.

{\ttfamily sudo rosdep init \&\& rosdep update \&\& rosdep install -\/-\/from-\/paths src -\/-\/ignore-\/src -\/r -\/y}\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md46}{}\doxysection{Configuration and Running}\label{md_spatio_temporal_voxel_layer_README_autotoc_md46}
\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md47}{}\doxysubsection{costmap\+\_\+common\+\_\+params.\+yaml}\label{md_spatio_temporal_voxel_layer_README_autotoc_md47}
An example fully-\/described configuration is shown below.

Note\+: We supply two P\+CL filters within S\+T\+VL to massage the data to lower compute overhead. S\+T\+VL has an approximate voxel filter to make the data more sparse if very dense. It also has a passthrough filter to limit processing data within the valid minimum to maximum height bounds. The voxel filter is recommended if it lowers C\+PU overhead, otherwise, passthrough filter. No filter is also available if you pre-\/process your data or are not interested in performance optimizations.


\begin{DoxyCode}{0}
\DoxyCodeLine{rgbd\_obstacle\_layer:}
\DoxyCodeLine{  enabled:               true}
\DoxyCodeLine{  voxel\_decay:           20     \#seconds if linear, e\string^n if exponential}
\DoxyCodeLine{  decay\_model:           0      \#0=linear, 1=exponential, -\/1=persistent}
\DoxyCodeLine{  voxel\_size:            0.05   \#meters}
\DoxyCodeLine{  track\_unknown\_space:   true   \#default space is unknown}
\DoxyCodeLine{  observation\_persistence: 0.0  \#seconds}
\DoxyCodeLine{  max\_obstacle\_height:   2.0    \#meters}
\DoxyCodeLine{  unknown\_threshold:     15     \#voxel height}
\DoxyCodeLine{  mark\_threshold:        0      \#voxel height}
\DoxyCodeLine{  update\_footprint\_enabled: true}
\DoxyCodeLine{  combination\_method:    1      \#1=max, 0=override}
\DoxyCodeLine{  obstacle\_range:        3.0    \#meters}
\DoxyCodeLine{  origin\_z:              0.0    \#meters}
\DoxyCodeLine{  publish\_voxel\_map:     true   \# default off}
\DoxyCodeLine{  transform\_tolerance:   0.2    \# seconds}
\DoxyCodeLine{  mapping\_mode:          false  \# default off, saves map not for navigation}
\DoxyCodeLine{  map\_save\_duration:     60     \#default 60s, how often to autosave}
\DoxyCodeLine{  observation\_sources:   rgbd1\_clear rgbd1\_mark}
\DoxyCodeLine{  rgbd1\_mark:}
\DoxyCodeLine{    data\_type: PointCloud2}
\DoxyCodeLine{    topic: camera1/depth/points}
\DoxyCodeLine{    marking: true}
\DoxyCodeLine{    clearing: false}
\DoxyCodeLine{    min\_obstacle\_height: 0.3     \#default 0, meters}
\DoxyCodeLine{    max\_obstacle\_height: 2.0     \#defaule 3, meters}
\DoxyCodeLine{    expected\_update\_rate: 0.0    \#default 0, if not updating at this rate at least, remove from buffer}
\DoxyCodeLine{    observation\_persistence: 0.0 \#default 0, use all measurements taken during now-\/value, 0=latest }
\DoxyCodeLine{    inf\_is\_valid: false          \#default false, for laser scans}
\DoxyCodeLine{    clear\_after\_reading: true    \#default false, clear the buffer after the layer gets readings from it}
\DoxyCodeLine{    filter: "voxel"              \#default passthrough, apply "voxel", "passthrough", or no filter to sensor data, recommended to have at one filter on}
\DoxyCodeLine{    voxel\_min\_points: 0          \#default 0, minimum points per voxel for voxel filter}
\DoxyCodeLine{  rgbd1\_clear:}
\DoxyCodeLine{    enabled: true                \#default true, can be toggled on/off with associated service call}
\DoxyCodeLine{    data\_type: PointCloud2}
\DoxyCodeLine{    topic: camera1/depth/points}
\DoxyCodeLine{    marking: false}
\DoxyCodeLine{    clearing: true}
\DoxyCodeLine{    min\_z: 0.1                   \#default 0, meters}
\DoxyCodeLine{    max\_z: 7.0                   \#default 10, meters}
\DoxyCodeLine{    vertical\_fov\_angle: 0.7      \#default 0.7, radians}
\DoxyCodeLine{    horizontal\_fov\_angle: 1.04   \#default 1.04, radians}
\DoxyCodeLine{    decay\_acceleration: 1.       \#default 0, 1/s\string^2. If laser scanner MUST be 0}
\DoxyCodeLine{    model\_type: 0                \#default 0 (depth camera). Use 1 for 3D Lidar}
\end{DoxyCode}


More configuration samples are included in the example folder, including a 3D lidar one.\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md48}{}\doxysubsection{local/global\+\_\+costmap\+\_\+params.\+yaml}\label{md_spatio_temporal_voxel_layer_README_autotoc_md48}
Add this plugin to your costmap params file.

{\ttfamily -\/ \{name\+: rgbd\+\_\+obstacle\+\_\+layer, type\+: \char`\"{}spatio\+\_\+temporal\+\_\+voxel\+\_\+layer/\+Spatio\+Temporal\+Voxel\+Layer\char`\"{}\}}\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md49}{}\doxysubsection{Running}\label{md_spatio_temporal_voxel_layer_README_autotoc_md49}
{\ttfamily roslaunch \mbox{[}navigation\+\_\+pkg\mbox{]} move\+\_\+base.\+launch}\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md50}{}\doxysubsection{Enabing/disabling observation\+\_\+sources real-\/time}\label{md_spatio_temporal_voxel_layer_README_autotoc_md50}
To enable/disable observation sources use a ros service for each source\+:

$\sim$rgbd\+\_\+obstacle\+\_\+layer//toggle\+\_\+enabled (std\+\_\+srvs/\+Set\+Bool)
\begin{DoxyItemize}
\item request.\+data = true // Enable observation source
\item request.\+data = false // Disable observation source
\end{DoxyItemize}

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rosservice call /move\_base/global\_costmap/rgbd\_obstacle\_layer/rgbd\_back/toggle\_enabled "data: true"}
\DoxyCodeLine{rosservice call /move\_base/local\_costmap/rgbd\_obstacle\_layer/rgbd\_back/toggle\_enabled "data: false"}
\end{DoxyCode}
\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md51}{}\doxysubsection{Debug and Model Fitting}\label{md_spatio_temporal_voxel_layer_README_autotoc_md51}
I have made the frustum transformations available for visualization and debugging. You may enable them by the {\ttfamily V\+I\+S\+U\+A\+L\+I\+Z\+E\+\_\+\+F\+R\+U\+S\+T\+UM} macro, though be aware it takes a substantial decrease on performance since we\textquotesingle{}re creating and destroying a ros publisher at a non-\/trivial rate.

This can also be used for situations where you do not know your camera\textquotesingle{}s proper frustum F\+O\+Vs. It is possible to enable it and tweek the F\+O\+Vs until you get the appropriate coverage of the space your sensor carves out in the global space. You should only do this with one sensor at a time or else your frustum in rviz might jitter around. ;-\/)\hypertarget{md_spatio_temporal_voxel_layer_README_autotoc_md52}{}\doxysubsection{Interesting side note}\label{md_spatio_temporal_voxel_layer_README_autotoc_md52}
We are able to iterate over very large grids for voxel decay, however there is clearly for every frequency (running at 1, 5, 10, 100hz) an upper limit. In the image below, we don\textquotesingle{}t actually hit the limit of the data structure, but iterating at 2hz, we hit the limit of R\+OS\textquotesingle{} ability to publish a sufficiently large point cloud in that time period, we are still running but you can see the robot at the end of an aisle without occupancy points, but still costmap marking from the underlying grid.

To counter this I include a service to save the grid in the .vdb format for later visualization, and for this reason I do not recommend visualizing the grid during nominal operations unless your decay time is relatively low (0-\/15 seconds) or else the layer may not meet its frequency requirements due to publishing this massive pointcloud.

 